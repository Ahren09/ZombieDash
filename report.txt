All Goodies have depth=1.0


The following two are not needed in ActivatingObject class
	virtual ~ActivatingObject();
	virtual void doSomething();

Since the function that calls it passes in an Actor*
setInfectionStatus() must be defined in Actor class(which can be pure virtual function)
It can be redefined in Human class


I was thinking of putting clearInfection() in Penelope class, since a citizen's infection
status cannot be cleared once it's infected

void clearInfection()
{
    infectionCount=0;
    infectedStatus=false;
}

However, since infectedStatus is a private data member of Human class, I have no way to
access this variable aside from defining a function in Human class

Thus I define this function in Penelope class, and redefine it in Citizen class:
void clearInfection()
{}

so that a Citizen's infection status will never be erased accidentally


Here is my initialization of a function that computes location with respect to direction
an actor is facing
bool StudentWorld::getNewPositionWithDir(Direction dir, double& x, double& y)
{
    if( dir==Actor::left || dir == Actor::right )
        return determineNewPosition(dir, x, y, SPRITE_WIDTH);
    else return determineNewPosition(dir, x, y, SPRITE_HEIGHT);
}

Since we see that left/right/up/down are const int defined in GraphObject, "Actor::" must
be added to indicate that


//###############
To iterate through a list within a const function, we must use a const iterator since the
compiler assumes that we do NOT alter the list.
for(list<Actor*>::const_iterator it=m_actors.begin();it!=m_actors.end();it++)


//###############
Format of using a reference to a pointer
'*' should be placed before '&'
For example, if we are to declare an Actor pointer:
	Actor* &a

//###############
About Consolidating functions
//Set all Actors burned by Flame to dead
void killByFlameIfAppropriate(Flame* flame);
    
//Set all Agent falling into Pit to dead
void killByPitIfAppropriate(Pit* pit);


Since they all operate on StudentWorld class,
void activateOnAppropriateActors(Actor* a);


I place all playSound() inside respective Actor class


//###############
If we define a virtual function inside a base class, we must provide an empty implementation 

For example:
virtual void activateIfAppropriate(Actor* a);

If in some classes, we are not overriding activateIfAppropriate(), we can write:
virtual void activateIfAppropriate(Actor* a){}
inside base class

//###############
I define a doSomething() in Goodie class, which call their respective pickup(Penelope* p)

When I compile, I got the error message:

 "vtable for GasCanGoodie", referenced from:
      GasCanGoodie::GasCanGoodie(StudentWorld*, double, double) in Actor.o
  NOTE: a missing vtable usually means the first non-inline virtual member function has no definition.


I should NOT declare doSomething() again if I am not to redefine doSomething() inside the 3 Goodie classes in Actor.h. Otherwise, the compiler expects that I provide a new implementation of doSomething(), which can NOT be empty.

